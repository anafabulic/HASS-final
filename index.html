<!DOCTYPE html>
<html>
<head>

    <meta charset="UTF-8">
    <title>Singapore's Longest Bus Rides</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <link rel="stylesheet" href="css/styles.css">

</head>

<body>

<div class="grid">

    <div class="block gutter">
        <h1>Whatever Happened To The Long Bus Ride?</h1>
        <br>
    </div>

    <div class="block gutter">
        <svg id="all_buses"></svg>
    </div>

    <div class="block gutter">
        <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Sit amet tellus cras adipiscing. Euismod nisi porta lorem mollis aliquam. Nisl rhoncus mattis rhoncus urna neque. Dictumst quisque sagittis purus sit amet. Commodo quis imperdiet massa tincidunt nunc pulvinar sapien et. Ac turpis egestas integer eget aliquet nibh. Feugiat sed lectus vestibulum mattis. Elementum integer enim neque volutpat. Ipsum dolor sit amet consectetur adipiscing elit. Quisque sagittis purus sit amet. Id diam vel quam elementum pulvinar etiam. Non sodales neque sodales ut etiam sit. Pharetra vel turpis nunc eget.
        </p>
    </div>

    <div class="block gutter">
        <p>
            Enim eu turpis egestas pretium aenean pharetra. Et odio pellentesque diam volutpat commodo sed egestas egestas fringilla. Id venenatis a condimentum vitae sapien pellentesque habitant. Nibh sed pulvinar proin gravida hendrerit. Arcu non sodales neque sodales ut etiam sit. Aliquam eleifend mi in nulla. Vitae elementum curabitur vitae nunc sed velit dignissim sodales. Aliquam ultrices sagittis orci a scelerisque purus semper. Congue quisque egestas diam in. Metus dictum at tempor commodo. Sed sed risus pretium quam vulputate dignissim suspendisse. Ac ut consequat semper viverra. Vel pharetra vel turpis nunc eget lorem dolor sed viverra. Rhoncus est pellentesque elit ullamcorper dignissim cras. Dui nunc mattis enim ut tellus.
        </p>
    </div>

    <div class="block gutter">
        <div class="svg_rl_dropdown"></div>
        </br>
        <svg id="route_lengths"></svg>
        <div class="svg_rl_slider"></div>
    </div>

    <div class="block gutter">
        <p>
            Eget aliquet nibh praesent tristique magna sit amet purus gravida. Est ultricies integer quis auctor elit sed vulputate mi. Posuere lorem ipsum dolor sit amet consectetur adipiscing elit. Varius duis at consectetur lorem. Lacus vestibulum sed arcu non odio euismod lacinia at. Nisl vel pretium lectus quam id leo in. Viverra nibh cras pulvinar mattis. Auctor urna nunc id cursus metus aliquam eleifend. Amet tellus cras adipiscing enim. Malesuada proin libero nunc consequat interdum varius sit amet. Venenatis a condimentum vitae sapien pellentesque habitant morbi. Orci ac auctor augue mauris augue neque. Donec adipiscing tristique risus nec feugiat in fermentum posuere urna. Quam lacus suspendisse faucibus interdum posuere.
        </p>
    </div>

    <div class="block gutter">
        <div><form class="svg_ls_input" action="#"></form></div>
        <svg id="longest_shortest"></svg>
    </div>

    <div class="block gutter">
        <p>
            Eget aliquet nibh praesent tristique magna sit amet purus gravida. Est ultricies integer quis auctor elit sed vulputate mi. Posuere lorem ipsum dolor sit amet consectetur adipiscing elit. Varius duis at consectetur lorem. Lacus vestibulum sed arcu non odio euismod lacinia at. Nisl vel pretium lectus quam id leo in. Viverra nibh cras pulvinar mattis. Auctor urna nunc id cursus metus aliquam eleifend. Amet tellus cras adipiscing enim. Malesuada proin libero nunc consequat interdum varius sit amet. Venenatis a condimentum vitae sapien pellentesque habitant morbi. Orci ac auctor augue mauris augue neque. Donec adipiscing tristique risus nec feugiat in fermentum posuere urna. Quam lacus suspendisse faucibus interdum posuere.
        </p>
    </div>

    <div class="block gutter">
        <svg id="route_viewer"></svg>
    </div>

    <div class="block gutter" style="height:100px;">
        <div>
            <p>
                Source(s): etc. etc. etc.
            </p>
            <p>
                Credits: etc. etc. etc.
            </p>
        </div>
    </div>

</div>

<!-- d3 version 7.4.2 -->
<script src="scripts/d3.min.js"></script>
<script>

// Define dimensions
let w = 1000, h = 600, gutter = 20;

// Define helper functions

// 1. Ordinal generator
let ordinal = (number) => {
    let ordinalRules = new Intl.PluralRules("en", {
        type: "ordinal"
    });
    let suffixes = {
        one: "st",
        two: "nd",
        few: "rd",
        other: "th"
    };
    let suffix = suffixes[ordinalRules.select(number)];
    return (number + suffix);
}
// 2. Mean calculator
let mean = (array) => {
    let total = 0;
    let count = 0;
    array.forEach(function(item) {
        total += item;
        count++;
    });
    return total / count;
}

// Define d3 selections
let svg_ab = d3.select("svg#all_buses")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_ls = d3.select("svg#longest_shortest")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_rl = d3.select("svg#route_lengths")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_rv = d3.select("svg#route_viewer")
    .attr("viewBox", `0 0 ${w} ${h}`);

// Define URIs
let data_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/service_summary.json";
let basemap_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/sg_plnarea_simple.geojson";
let stop_coords_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/stop_coords.json";
let stop_counts_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/stop_counts.json";

Promise.all(
    [   d3.json(data_uri),
        d3.json(basemap_uri),
        d3.json(stop_coords_uri),
        d3.json(stop_counts_uri)   ]).then(data => {
    
    // Define variables/objects; rewind data[0] as basemap
    let routes = data[0];
    let basemap = data[1];
    let basemap_r = basemap.features;
    for (let i = 0; i < basemap_r.length; i++) {
        if (basemap_r[i].geometry.type == "MultiPolygon") {
            for (let j = 0; j < basemap_r[i].geometry.coordinates.length; j++) {
                basemap_r[i].geometry.coordinates[j][0].reverse();
            }
        } else {
            basemap_r[i].geometry.coordinates[0].reverse();
        }
    }; 
    basemap.features = basemap_r;
    let stop_coords = data[2];
    let stop_counts = data[3];
    let ranges = {};

    console.log(basemap);
    console.log(routes);
    console.log(stop_coords);
    console.log(stop_counts);

// 1. Drawing svg all_buses
        
    // Define d3 projection
    let projection = d3.geoMercator()
        .fitExtent(
            [
                [gutter, gutter],
                [w - gutter, h - gutter]
            ],
            basemap
        );
    let geopath = d3.geoPath().projection(projection);

    // Draw map
    svg_ab.append("g")
        .attr("class", "basemap")
        .selectAll("path")
        .data(basemap.features)
        .enter()
        .append("path")
        .attr("d", geopath);
    
    // Build + clean stop data 
    let stops = [];
    Object.entries(stop_coords).forEach(function(item) {
        stops.push(
            {
                "stop":      item[0],
                "latitude":  item[1][0],
                "longitude": item[1][1],
                "count":     stop_counts[item[0]]
            }
        );
    });
    stops.sort((a,b) => {
        return a.count - b.count;
    });
    
    // Calculate min and max stopcounts
    ranges.svg_ab = [1e6, 0] // [min, max]
    stops.forEach(function(item) {
        if (item.count < ranges.svg_ab[0]) {
            ranges.svg_ab[0] = item.count;
        }
        if (item.count > ranges.svg_ab[1]) {
            ranges.svg_ab[1] = item.count;
        }
    });

    // Construct colorscale, radius scale, etc.
    let cs_svg_ab = d3.scaleSequential()
        .domain(ranges.svg_ab)
        .range([0.95,0.05]); // not pegging [1,0] because if you're setting other attributes by d.count you want a reasonable nonzero somewhere.
    function cs_svg_r_maker(float) {
        let r = 6.5;
        return ((1 - cs_svg_ab(float))*r) + 1
    };

    // Draw the stops
    // TODO: slider that filters most-used stops from lesser-used stops?
    // TODO: or a button that changes the view to hexbin/counts?
    // see : https://observablehq.com/@mbostock/walmarts-growth 
    svg_ab.append("g")
        .selectAll("circle")
        .data(stops)
        .join(
            function(enter) {
                return enter
                    .append("circle")
                    .attr("class", "svg_ab_pts")
                    .attr("cx", d => projection([d.longitude, d.latitude])[0] )
                    .attr("cy", d => projection([d.longitude, d.latitude])[1] )
                    .attr("id", d => d.stop)
                    .attr("r", "0.01px")
                    // .attr("fill-opacity", d => (1 - cs_svg_ab(d.count)))
            }
        )
        .transition()
        .delay(d => (1 - cs_svg_ab(d.count))*1250) // fancy fade-in based on d.count
        .duration(750)
        .attr("r", d => cs_svg_r_maker(d.count).toString() + "px")
        .attr("fill-opacity", "0.85")
        .attr("fill", d => d3.interpolateInferno(cs_svg_ab(d.count)));

// 2. Drawing svg longest_shortest

    // Draw basemap
    svg_ls.append("g")
        .attr("class", "basemap")
        .selectAll("path")
        .data(basemap.features)
        .enter()
        .append("path")
        .attr("d", geopath);
    
    // Input box
    // TODO: https://www.w3schools.com/howto/howto_js_autocomplete.asp
    d3.select("form.svg_ls_input")
        .append("input")
        .attr("type", "text")
        .attr("size", "15px")
        .attr("name", "ls_input")
        .attr("id", "ls_input")
        .attr("placeholder", "Enter bus route...\u2000");
    let route_list = routes.map(({route}) => {return route});
    function autocomplete(inp, arr) {
        /*the autocomplete function takes two arguments,
        the text field element and an array of possible autocompleted values:*/
        var currentFocus;
        /*execute a function when someone writes in the text field:*/
        inp.addEventListener("input", function(e) {
            var a, b, i, val = this.value;
            /*close any already open lists of autocompleted values*/
            closeAllLists();
            if (!val) { return false;}
            currentFocus = -1;
            /*create a DIV element that will contain the items (values):*/
            a = document.createElement("DIV");
            a.setAttribute("id", this.id + "autocomplete-list");
            a.setAttribute("class", "autocomplete-items");
            /*append the DIV element as a child of the autocomplete container:*/
            this.parentNode.appendChild(a);
            /*for each item in the array...*/
            for (i = 0; i < arr.length; i++) {
                /*check if the item starts with the same letters as the text field value:*/
                if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
                /*create a DIV element for each matching element:*/
                b = document.createElement("DIV");
                /*make the matching letters bold:*/
                b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
                b.innerHTML += arr[i].substr(val.length);
                /*insert a input field that will hold the current array item's value:*/
                b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
                /*execute a function when someone clicks on the item value (DIV element):*/
                    b.addEventListener("click", function(e) {
                    /*insert the value for the autocomplete text field:*/
                    inp.value = this.getElementsByTagName("input")[0].value;
                    /*close the list of autocompleted values,
                    (or any other open lists of autocompleted values:*/
                    closeAllLists();
                });
                a.appendChild(b);
                }
            }
        });
        /*execute a function presses a key on the keyboard:*/
        inp.addEventListener("keydown", function(e) {
            var x = document.getElementById(this.id + "autocomplete-list");
            if (x) x = x.getElementsByTagName("div");
            if (e.keyCode == 40) {
                /*If the arrow DOWN key is pressed,
                increase the currentFocus variable:*/
                currentFocus++;
                /*and and make the current item more visible:*/
                addActive(x);
            } else if (e.keyCode == 38) { //up
                /*If the arrow UP key is pressed,
                decrease the currentFocus variable:*/
                currentFocus--;
                /*and and make the current item more visible:*/
                addActive(x);
            } else if (e.keyCode == 13) {
                /*If the ENTER key is pressed, prevent the form from being submitted,*/
                e.preventDefault();
                if (currentFocus > -1) {
                /*and simulate a click on the "active" item:*/
                if (x) x[currentFocus].click();
                }
            }
        });
        function addActive(x) {
            /*a function to classify an item as "active":*/
            if (!x) return false;
            /*start by removing the "active" class on all items:*/
            removeActive(x);
            if (currentFocus >= x.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = (x.length - 1);
            /*add class "autocomplete-active":*/
            x[currentFocus].classList.add("autocomplete-active");
        }
        function removeActive(x) {
            /*a function to remove the "active" class from all autocomplete items:*/
            for (var i = 0; i < x.length; i++) {
            x[i].classList.remove("autocomplete-active");
            }
        }
        function closeAllLists(elmnt) {
            /*close all autocomplete lists in the document,
            except the one passed as an argument:*/
            var x = document.getElementsByClassName("autocomplete-items");
            for (var i = 0; i < x.length; i++) {
            if (elmnt != x[i] && elmnt != inp) {
            x[i].parentNode.removeChild(x[i]);
            }
        }
        }
        /*execute a function when someone clicks in the document:*/
        document.addEventListener("click", function (e) {
            closeAllLists(e.target);
        });
    } 
    autocomplete(document.getElementById("ls_input"), route_list);

    // Populate route data .
    let svg_ls_data = [];
    // Very hacky interlude
    routes.sort((a,b) => {
        return b["max_km"] - a["max_km"];
    });
    routes.forEach(function(item, index) {
        item.max_km_ordinal = index + 1;
    });
    routes.sort((a,b) => {
        return b["length"] - a["length"];
    });
    // End of interlude
    routes.forEach(function(item, index) {
        // Create a geoJSON linestring between consecutive bus stops, then append all linestrings to a single 'links' dataset
        let stoplist = item.stops; 
        let links = [];
        for (var i=0, len=stoplist.length-1; i<len; i++) {
            links.push({
                type: "LineString",
                coordinates: [
                    [stoplist[i].longitude, stoplist[i].latitude],
                    [stoplist[i+1].longitude, stoplist[i+1].latitude]        
                ]
            });
        };
        svg_ls_data.push({
            route_no: item.route,
            route: links,
            length: item.length,
            max_km: item.max_km,
            max_km_ordinal: item.max_km_ordinal,
            ordinal: index + 1
        });  
    });
    let svg_ls_g = svg_ls.append("g")
            .attr("id", "svg_ls_routes");
    
    // Draw the links
    // TODO: Time-based update that can be paused and manually-set via textbox
    function update_ls(data) {
        data.forEach(function(item) {
            svg_ls_g.selectAll("path")
                .data(item.route)
                .join(
                    function(enter) {
                        return enter
                            .append("path")
                            .attr("class", "svg_ls_ln")
                            .attr("stroke-opacity", "0.01");
                    },
                    function(update) {
                        return update
                            .transition()
                            .duration(750)
                            .attr("stroke-opacity", "0.01");
                    },
                    function(exit) {
                        return exit
                            .transition()
                            .duration(750)
                            .attr("stroke-opacity", "0.01")
                            .on("end", function() {
                                d3.select(this).remove();
                            });
                    }
                )
                .transition()
                .duration(1000)
                .attr("stroke-opacity", "0.30")
                .attr("d",geopath);
        });
    };

    let svg_ls_text = svg_ls.append("g")
        .attr("id", "svg_ls_txt");
    
    function update_ls_text(data) {
        // Add pointer to label
        svg_ls_text.selectAll("path")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("path")
                        .attr("class", "svg_ls_ptr");
                },
                function(update) {
                    return update
                },
                function(exit) {
                    return exit
                        .transition()
                        .duration(750)
                        .attr("stroke-opacity", "0.01")
                        .on("end", function() {
                            d3.select(this).remove();
                        });      
                }
            )
            .attr("stroke-opacity", "0.75")
            .transition()
            .duration(1000)
            .attr("d", d => 
                "M" + projection(d.route[0].coordinates[0])[0] +
                "," + projection(d.route[0].coordinates[0])[1] +
                "L" + "730" +
                "," + "510"
            );
        
        // Hack to 'buffer' the label
        svg_ls_text.selectAll("rect")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("rect")
                        .attr("x", "700")
                        .attr("y", "490")
                        .attr("width", "100px")
                        .attr("height", "100px")
                        .attr("fill", "var(--bg0)")
                        .attr("transform", "translate(-15, -30)");
                }
            );

        // Add label
        let textspace = svg_ls_text.selectAll("text")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("text")
                        .attr("class", data.route_no)
                        .attr("transform", "translate(700,490)");
                },
                function(exit) {
                    return exit
                        .on("end", function() {
                            d3.select(this).remove();
                        });
                }
            );
        
        textspace.text(d => "Bus " + d.route_no)
            .attr("dy","0")
            .attr("font-size", "1.2em")
            .transition()
            .duration(1000)
            .attr("transform", "translate(700,490)");
        
        textspace.append("tspan")
            .attr("dy", "1.5em")
            .attr("x", 0)
            .attr("font-size", "0.8em")
            .text(d => d.length + " stops (" + ordinal(d.ordinal) + "-longest)");

        textspace.append("tspan")
            .attr("dy", "1.5em")
            .attr("x", "0")
            .attr("font-size", "0.8em")
            .text(d => d.max_km + " km (" + ordinal(d.max_km_ordinal) + "-longest)");

    };

    // Set initial values
    let initialValue = "51";
    let filteredArray = svg_ls_data.filter(function(obj) {
        return obj.route_no === initialValue;
    });
    update_ls(filteredArray);
    update_ls_text(filteredArray);

    // Listen to the input box
    d3.select("#ls_input").on("change", function(d) {
        let selectedValue = this.value;
        let filteredArray = svg_ls_data.filter(function(item) {
            return item.route_no === selectedValue;
        });
        // Hacky update trick: update_ls_text exits nicely on empty array, but update_ls panics if there are no elements in route[].
        // Hence: do update_ls_text, then populate route if filteredArray is empty, then do update_ls.
        update_ls_text(filteredArray);
        if (filteredArray.length == 0) {
            filteredArray.push({
                route_no: null,
                route: [{}],
                length: null,
                max_km: null,
                max_km_ordinal: null,
                ordinal: null
            });
        };
        update_ls(filteredArray);
    });
    
    // The long, straight lines crossing the island are normal. They represent cross-island services with very large distances between stops.

// 3. Drawing svg route_lengths (bar charts of route lengths)

    // Define min/max      
    ranges.svg_rl = {}  
    ranges.svg_rl.length = [1e6, 0]; // min, max
    routes.forEach(function(item) {
        if (item.length < ranges.svg_rl.length[0]) {
            ranges.svg_rl.length[0] = item.length;
        };
        if (item.length > ranges.svg_rl.length[1]) {
            ranges.svg_rl.length[1] = item.length;
        };
    });
    ranges.svg_rl.max_km = [1e6, 0]; // min, max
    routes.forEach(function(item) {
        if (item.max_km < ranges.svg_rl.max_km[0]) {
            ranges.svg_rl.max_km[0] = item.max_km;
        };
        if (item.max_km > ranges.svg_rl.max_km[1]) {
            ranges.svg_rl.max_km[1] = item.max_km;
        };
    });
    
    // Initialise some important cosmetic variables
    let svg_rl_viewlimit = 50; // Limit at which y-axis text stops being visible
    let svg_rl_viewlimit2 = 100; // Limit at which lollipops become bars
    let svg_rl_init = 25; // Initialise zoom level at this value

    // Attach inputs
    d3.select("div.svg_rl_slider")
        .append("input")
        .attr("type", "range")
        .attr("min", "0")
        .attr("max", "100")
        .attr("value", svg_rl_init)
        .attr("name", "rl_slider")
        .attr("id", "rl_slider")
        .attr("class", "slider");
    let svg_rl_dropdown_form = d3.select("div.svg_rl_dropdown")
        .append("form");
    svg_rl_dropdown_form.append("label")
            .attr("for", "rl_dropdown")
            .text("Sort route by: ")
    let svg_rl_dropdown_form_select = svg_rl_dropdown_form.append("select")
        .attr("name", "rl_dropdown")
        .attr("id", "rl_dropdown");
    svg_rl_dropdown_form_select.append("option")
        .attr("value", "max_km")
        .text("length (km)");
    svg_rl_dropdown_form_select.append("option")
        .attr("value", "length")
        .text("number of stops");
    
    // Define selection to render on
    let svg_rl_bc = svg_rl.append("g")
        .attr("id", "svg_rl_chart")
        .attr("transform", "translate(100,40)");
    let svg_rl_bars = svg_rl_bc.append("g")
        .attr("class", "svg_rl_bars");
    let svg_rl_x = svg_rl_bc.append("g")
        .attr("class", "x_axis");
    let svg_rl_x2 = svg_rl_bc.append("g")
        .attr("class", "x_axis2")
    let svg_rl_y = svg_rl_bc.append("g")
        .attr("class", "y_axis");

    function update_rl(data, slice, factor) {
        // Sort and slice
        data.sort((a,b) => {
            return b[factor] - a[factor];
        });
        let working_data = data.slice(0,slice);

        // Define scales and axes
        let x_scale = d3.scaleLinear()
            .domain([0, ranges.svg_rl[factor][1]*1.05])
            .range([0, w * 0.80])
            .nice();
        let y_scale = d3.scaleBand()
            .domain(working_data.map(({route}) => {return route}))
            .range([0, h * 0.85])
            .paddingInner(0.05);
        svg_rl_bars.attr("transform", "translate(0," + y_scale.bandwidth()/2 + ")");
        let x_axis = d3.axisTop(x_scale);
        let x_axis2 = d3.axisBottom(x_scale);
        let y_axis = d3.axisLeft(y_scale)
            .tickSizeInner(0);


        // Setup axes
        svg_rl_x.call(x_axis)
            .attr("class", "svg_rl_x")
            .attr("transform", "translate(0,-20)");
        svg_rl_x2.call(x_axis2)
            .attr("class", "svg_rl_x2")
            .attr("transform", "translate(0," + (h * 0.90).toString() + ")");
        svg_rl_y.call(y_axis)
            .attr("class", "svg_rl_y");
        
        // Remove y-axis labels if too crowded
        // Also hacked together a 'zoom-out' resize rule
        if (slice <= svg_rl_viewlimit) {
            d3.select(".svg_rl_y").attr("style", "font-size:" + (1-(slice/svg_rl_viewlimit)).toString() + "em;stroke-width:0px;font:'Lato',sans-serif;");
        } else {
            d3.select(".svg_rl_y").attr("style", "font-size:0.0em;stroke-width:1px;font:'Lato',sans-serif;");
        }

        // represent with rect so can 'morph' into a density chart seamlessly with rect-height
        svg_rl_bars.selectAll("rect")
            .data(working_data)
            .join(
                function(enter) {
                    return enter
                        .append("rect")
                        .attr("x", x_scale(0))
                        .attr("y", d => y_scale(d.route))
                        .attr("width", "0px")
                        .attr("stroke-width", "0px")
                        .attr("fill", "var(--org)");
                },
                function(update) {
                    return update
                        .attr("y", d => y_scale(d.route));
                },
                function(exit) {
                    return exit
                        .remove();
                }
            )
            .transition()
            .duration(1000)
            .attr("width", d => `${x_scale(d[factor])}px`)
            .attr("height", d => {
                if (
                    slice > svg_rl_viewlimit2 &&
                    working_data.includes(d, Math.floor(985/1000*working_data.length))
                    // Shave off last 1.5% of values when zoomed out
                ) {
                    return "0px";   
                } else if (slice <= svg_rl_viewlimit2) {
                    return "1px";
                    // then turn area chart into lollipops when zoomed in
                } else {
                    return "8px";
                // then turn lollipops into area chart when zoomed out and not in last 1.5% 
                }
            });

        svg_rl_bars.selectAll("circle")
            .data(working_data)
            .join(
                function(enter) {
                    return enter
                        .append("circle")
                        .attr("cx", x_scale(0))
                        .attr("cy", d => y_scale(d.route))
                        .attr("r", "0px");
                },
                function(update) {
                    return update
                        .attr("cy", d => y_scale(d.route));
                },
                function(exit) {
                    return exit
                        .remove();
                }
            )
            .transition()
            .duration(1000)
            .attr("r", d => {
                if (slice <= svg_rl_viewlimit) {
                    return "4px";
                } else if (slice <= svg_rl_viewlimit2) {
                    return "2px";
                } else {
                    return "0px";
                };
            })
            .attr("cx", d => x_scale(d[factor]));
        
    };


    // Some kind of benchmark to visualise how many bus routes are 'too long' according to maybe some LTA metric...
    // let mean_route_length = mean(routes.map(({length}) => {return length}));
    // svg_rl_bars.append("line")
    //     .attr("id", "svg_rl_mean")
    //     .attr("x1", x_scale(mean_route_length))
    //     .attr("y1", (h * 0.15).toString())
    //     .attr("x2", x_scale(mean_route_length))
    //     .attr("y2", (h * 0.85).toString())
    //     .attr("style", "stroke:black;stroke-width:1px;");
    
    // very magic function (DO NOT TOUCH)
    function svg_rl_smooth(x) {
        if (x <= 50) {
            return (8 + (42/33*(x-0)) )
        } else if (x <= 66) {
            return (50 + (50/33*(x-33)) )
        } else {
            return (100 + ((routes.length-100)/34*(x-66)) )
        }
    };
    let svg_rl_facet = "max_km"; // length or max_km
    let svg_rl_slice = svg_rl_init;
    update_rl(routes, svg_rl_init, svg_rl_facet); // initialise

    d3.select("#rl_slider").on("input", function(d) {
        let raw_value = this.value;
        svg_rl_slice = svg_rl_smooth(raw_value);
        update_rl(routes, svg_rl_slice, svg_rl_facet); // data, slice, factor
    });

    d3.select("#rl_dropdown").on("input", function(d) {
        svg_rl_facet = this.value;
        update_rl(routes, svg_rl_slice, svg_rl_facet); // data, slice, factor
    });


// 4. Drawing svg route_viewer (live bus locator based on bus stop) (optional)
// ?. Hexbin of bus service density (number of lines * number of stops) (basically a raw count of all lines' stops within a hex) (can divide by number of stops to figure out number of lines passing through a hex)

});

</script>

</body>
</html>

