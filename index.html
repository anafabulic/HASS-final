<!DOCTYPE html>
<html>
<head>

    <meta charset="UTF-8">
    <title>In Defense of the Long Bus Ride</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <link rel="stylesheet" href="css/styles.css">

</head>

<body>

<div class="grid">

    <div class="block gutter">
        <h1 style="text-align:center;">In Defense of the Long Bus Ride</h1>
        <p style="text-align:center;margin:0 0 20px;">
            <small>A data story for <a href="" target="_blank">HASS02.546: Interactive Data Visualisation</a></small>
        </p>
    </div>

    <div class="block gutter" style="margin:0 5% 100px;">
        <div class="col-50">
            <div class="block gutter">
            <p style="text-align:left;font-style:italic;">
                <small>created by <a href="https://github.com/anafabulic/" target="_blank">Sean Chua</a></small>
            </p>
            </div>
        </div>
        <div class="col-50">
            <div class="block gutter">
            <p style="text-align:right;font-style:italic;">
                <small>24 April 2022</a></small>
            </p>
            </div>
        </div>
    </div>

    <div class="block gutter">
        <p>
            The roots of this data story came from my interviews with residents in the soon-to-be demolished neighbourhood of Tanglin Halt. When I asked them what they&rsquo;d miss most about the place, a surprising number mentioned the area&rsquo;s bus connections as a main selling point. There are few feeder buses in the old neighbourhoods lining Singapore&rsquo;s south-west coast&mdash;unlike the new towns, most bus services ply long lines straight to the city centre or across the island, with the end result being that you don&rsquo;t have to live near a train station to get to anywhere worth going. I immediately thought of the services that ran past my house and how they always took you back from the furthest places. Like them or not, long bus rides are a crucial part of our public transport network, serving all sorts of niche populations like the change-resistant elderly and the unfortunate young partygoer who&rsquo;s 10 train stops away from home after midnight and can&rsquo;t afford a Grab.
        </p>
    </div>

    <div class="block gutter">
        <svg id="all_buses"></svg>
    </div>

    <div class="block gutter">
        <p>
            On a map of all bus stops, these trunk services are visible amidst the constellation of routes as faint, dark lines running through the prime cross-island roads: the four spokes of Marymount Road, Upper Thomson Road, Serangoon Road, and Geylang Road as faint orange bands leading to the dark brown hub of the Central Business District. The persistence of such routes runs contrary to the Land Transport Authority&rsquo;s planning doctrine, where the <a href="https://www.researchgate.net/publication/312813677_Engineering_Singapore's_Land_Transport_System" target="_blank">hub-and-spoke</a> model of transport planning dominates the integration of newer, shorter feeder services with the rail network. When mapped out like this, Singapore&rsquo;s trunk routes appear a faint anachronism of an older, bus-dominated public transport landscape atop the backbones of colonial-era roads. 
        </p>
        <p>
            There is, however, little-to-no documentation on what constitutes a &lsquo;long&rsquo; bus ride. Then-Second Minister for Transport Lim Hwee Hua explained in <a href="https://sprs.parl.gov.sg/search/topic?reportid=008_20100816_S0006_T0004" target="_blank">a 2010 Parliament session</a> that a route length of 20-37 km could be viewed as excessive by some. She also mentioned that the LTA does phase out trunk routes when it&rsquo;s clear that most of its users don&rsquo;t travel on it for the full length. It can, and it has: during <a href="https://www.straitstimes.com/singapore/politics/budget-debate-95-million-saved-yearly-by-shortening-3-bus-routes-says-chee-hong-tat-to-gerald-giam" target="_blank">this March&rsquo;s budget debate</a>, Aljunied MP Gerald Giam raised the issue of the shortening of long bus routes from his constituency to the CBD, which inconvenienced a bunch of older residents. And just two years earlier, Bukit Panjang MP Liang Eng Hwa also expressed <a href="https://www.channelnewsasia.com/singapore/bukit-panjang-bus-services-700-171-change-lta-public-funds-608936" target="_blank">some pretty strong disappointment</a> at the withdrawal of long bus services in his constituency following the opening of the Downtown Line. Is this the beginning of the end for trunk routes?
        </p>
        <p>
            According to the data, probably not.
        </p>
    </div>

    <div class="block gutter">
        <div class="svg_rl_dropdown"></div>
        </br>
        <svg id="route_lengths"></svg>
        <div class="svg_rl_slider"></div>
        <div>
            <p style="font-style:italic;text-align:center;">
                <small>(slide to zoom)</small>
            </p>
        </div>
    </div>

    <div class="block gutter">
        <p>
            Looking at the 554 bus routes provided by the LTA DataMall API, it&rsquo;s surprising just how many of them fit&mdash;or even exceed&mdash;that benchmark of 20-37 km. The longest service by distance between first and last stops is <a href="https://www.transitlink.com.sg/eservice/eguide/service_route.php?service=858" target="_blank">Tower Transit&rsquo;s 858 service</a>, covering a staggering total of 73.4 km over 75 stops. Many of these longest routes are also old ones, if the prevalence of two-digit numbers among the top 20 is anything to go by. Several, interestingly, are special services: route numbers in the 500s or containing an &lsquo;N&rsquo; are specific long-distance routes operated by private companies for the former or past midnight for the latter. A lot of these routes go by highways, which results in our map not showing their full extent (the DataMall API only allows querying for specific stops, not route).
        </p>
        <p>
            Going by number of stops, we see more routes in the top 20 numbered in the 0-99 range as well as the 100-199 range. This somewhat fits the pattern of path dependency observed in older legacy routes, winding through many neighbourhoods and usually passing through the city centre. The shape of these routes can be more clearly seen in our map.
        </p>
        <p>
            Here&rsquo;s an interactive version of the inset map so you can see where your favourite routes are:
        </p>
    </div>

    <div class="block gutter">
        <div><form class="svg_ls_input" autocomplete="off" action=""></form></div>
        <svg id="longest_shortest"></svg>
    </div>

    <div class="block gutter">
        <p>
            How many of these routes are &lsquo;too long&rsquo;? It&rsquo;s hard to say given the lack of live ridership data and the general clunkiness of querying bus frequency from the LTA DataMall. From the histogram below, we can find the mean and median route length by distance travelled and number of stops, but it can&rsquo;t tell us much about whether they&rsquo;re underused or not. What they can tell us is that [TODO...].
        </p>
    </div>

    <div class="block gutter">
        <svg id="route_viewer"></svg>
    </div>

    <div class="block gutter">
        <p>
            It&rsquo;s also clear that long bus routes provide excellent redundancy to Singapore&rsquo;s transport system&mdash;always a good thing, if the engineering podcast I listen to is anything to go by. Then-Minister for Transport Ong Ye Kung has <a href="(https://sprs.parl.gov.sg/search/sprs3topic?reportid=budget-1629)" target="_blank">admitted as much in Parliament</a> when he said that long routes remain a solid backbone to our transport network, even when most of them run at a loss. Most of our routes, in fact, are trunk routes, despite the speed and geographical extent of our rail lines. Shorter routes <a href="https://sprs.parl.gov.sg/search/topic?reportid=008_20100816_S0006_T0004" target="_blank">aren&rsquo;t necessarily more cost-effective</a> due to the limiting factors of fleet maintenance and drivers&rsquo; wages (as much as Minister Ang Wei Neng <a href="https://sprs.parl.gov.sg/search/sprs3topic?reportid=budget-1585" target="_blank">would like to think otherwise</a>). And even if shorter services are more reliable, one can&rsquo;t deny the added perceived annoyance and trip variability that multiple, brief transfers can add to an otherwise-seamless journey. If you&rsquo;re searching for an station entrance, crossing to a bus stop, or waiting for a couple of bunched-up feeders in a strange neighbourhood, all that wait time is going to add up.
        </p>
        <p>
            What the data can&rsquo;t tell us, however, are the associated impressions of mobility that have run deep over the years along these long bus lines. I can&rsquo;t tell you how many times the 162 has saved my life running past midnight along Plaza Singapura on a Friday night, or the weekly relief at taking the 52 back down Marymount Road from Maju Camp. It can&rsquo;t tell you how I know the shape of the 410 both ways from the drumming of my skull against the hideous beige walls. And the data is silent on that one elderly man in Tanglin Halt who can no longer take the bus from his doorstep to visit his old friends all along the southwest coast, from Clementi to Redhill and beyond. [TODO: Conclusion]
        </p>
    </div>

    <div class="block gutter" style="height:300px;">
        <!-- for bottom margin in the end -->
        <div>
            <p style="text-align:right;">
                </br>
                <small>Source(s): etc. etc. etc.</small>
            </p>
            <p style="text-align:right;">
                <small>Credits: etc. etc. etc.</small>
            </p>
        </div>
    </div>

</div>

<!-- d3 version 7.4.2 -->
<script src="scripts/d3.min.js"></script>
<script>

// Define dimensions
let w = 1000, h = 600, gutter = 20;

// Define helper functions

// 1. Ordinal generator
let ordinal = (number) => {
    let ordinalRules = new Intl.PluralRules("en", {
        type: "ordinal"
    });
    let suffixes = {
        one: "st",
        two: "nd",
        few: "rd",
        other: "th"
    };
    let suffix = suffixes[ordinalRules.select(number)];
    return (number + suffix);
}
// 2. Mean calcuInconsolatar
let mean = (array) => {
    let total = 0;
    let count = 0;
    array.forEach(function(item) {
        total += item;
        count++;
    });
    return total / count;
}

// Define d3 selections
let svg_ab = d3.select("svg#all_buses")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_ls = d3.select("svg#longest_shortest")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_rl = d3.select("svg#route_lengths")
    .attr("viewBox", `0 0 ${w} ${h}`);
let svg_rv = d3.select("svg#route_viewer")
    .attr("viewBox", `0 0 ${w} ${h}`);

// Define URIs
let data_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/service_summary.json";
let basemap_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/sg_plnarea_simple.geojson";
let stop_coords_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/stop_coords.json";
let stop_counts_uri = "https://raw.githubusercontent.com/anafabulic/HASS-final/main/json/stop_counts.json";

Promise.all(
    [   d3.json(data_uri),
        d3.json(basemap_uri),
        d3.json(stop_coords_uri),
        d3.json(stop_counts_uri)   ]).then(data => {
    
    // Define variables/objects; rewind data[0] as basemap
    let routes = data[0];
    let basemap = data[1];
    let basemap_r = basemap.features;
    for (let i = 0; i < basemap_r.length; i++) {
        if (basemap_r[i].geometry.type == "MultiPolygon") {
            for (let j = 0; j < basemap_r[i].geometry.coordinates.length; j++) {
                basemap_r[i].geometry.coordinates[j][0].reverse();
            }
        } else {
            basemap_r[i].geometry.coordinates[0].reverse();
        }
    }; 
    basemap.features = basemap_r;
    let stop_coords = data[2];
    let stop_counts = data[3];
    let ranges = {};

    console.log(basemap);
    console.log(routes);
    console.log(stop_coords);
    console.log(stop_counts);

// 1. Drawing svg all_buses
        
    // Define d3 projection
    let projection = d3.geoMercator()
        .fitExtent(
            [
                [gutter, gutter],
                [w - gutter, h - gutter]
            ],
            basemap
        );
    let geopath = d3.geoPath().projection(projection);

    // Draw map
    svg_ab.append("g")
        .attr("class", "basemap")
        .selectAll("path")
        .data(basemap.features)
        .enter()
        .append("path")
        .attr("d", geopath);
    
    // Build + clean stop data 
    let stops = [];
    Object.entries(stop_coords).forEach(function(item) {
        stops.push(
            {
                "stop":      item[0],
                "latitude":  item[1][0],
                "longitude": item[1][1],
                "count":     stop_counts[item[0]]
            }
        );
    });
    stops.sort((a,b) => {
        return a.count - b.count;
    });
    
    // Calculate min and max stopcounts
    ranges.svg_ab = [1e6, 0] // [min, max]
    stops.forEach(function(item) {
        if (item.count < ranges.svg_ab[0]) {
            ranges.svg_ab[0] = item.count;
        }
        if (item.count > ranges.svg_ab[1]) {
            ranges.svg_ab[1] = item.count;
        }
    });

    // Construct colorscale, radius scale, etc.
    let cs_svg_ab = d3.scaleSequential()
        .domain(ranges.svg_ab)
        .range([0.95,0.05]); // not pegging [1,0] because if you're setting other attributes by d.count you want a reasonable nonzero somewhere.
    function cs_svg_r_maker(float) {
        let r = 6.5;
        return ((1 - cs_svg_ab(float))*r) + 1
    };

    // Draw the stops
    // TODO: slider that filters most-used stops from lesser-used stops?
    //       or a button that changes the view to hexbin/counts?
    // see : https://observablehq.com/@mbostock/walmarts-growth 
    // TODO: add legend
    svg_ab.append("g")
        .selectAll("circle")
        .data(stops)
        .join(
            function(enter) {
                return enter
                    .append("circle")
                    .attr("class", "svg_ab_pts")
                    .attr("cx", d => projection([d.longitude, d.latitude])[0] )
                    .attr("cy", d => projection([d.longitude, d.latitude])[1] )
                    .attr("id", d => d.stop)
                    .attr("r", "0.01px")
                    // .attr("fill-opacity", d => (1 - cs_svg_ab(d.count)))
            }
        )
        .transition()
        .delay(d => (1 - cs_svg_ab(d.count))*1250) // fancy fade-in based on d.count
        .duration(750)
        .attr("r", d => cs_svg_r_maker(d.count).toString() + "px")
        .attr("fill-opacity", "0.85")
        .attr("fill", d => d3.interpolateInferno(cs_svg_ab(d.count)));

// 2. Drawing svg longest_shortest

    // Draw basemap
    svg_ls.append("g")
        .attr("class", "basemap")
        .selectAll("path")
        .data(basemap.features)
        .enter()
        .append("path")
        .attr("d", geopath);
    
    // Input box
    d3.select("form.svg_ls_input")
        .append("input")
        .attr("type", "text")
        .attr("size", "15px")
        .attr("list", "stops")
        .attr("name", "ls_input")
        .attr("id", "ls_input")
        .attr("placeholder", "Enter bus route...\u2000");
    let route_list = routes.map(({route}) => {return route});

    d3.select("form.svg_ls_input")
        .append("datalist")
        .attr("id", "stops")
        .selectAll("option")
        .data(route_list)
        .enter()
        .append("option")
        .attr("value", d => d)
        .text(d => d);

    // Populate route data .
    let svg_ls_data = [];
    // Very hacky interlude
    routes.sort((a,b) => {
        return b["max_km"] - a["max_km"];
    });
    routes.forEach(function(item, index) {
        item.max_km_ordinal = index + 1;
    });
    routes.sort((a,b) => {
        return b["length"] - a["length"];
    });
    // End of interlude
    routes.forEach(function(item, index) {
        // Create a geoJSON linestring between consecutive bus stops, then append all linestrings to a single 'links' dataset
        let stoplist = item.stops; 
        let links = [];
        for (var i=0, len=stoplist.length-1; i<len; i++) {
            links.push({
                type: "LineString",
                coordinates: [
                    [stoplist[i].longitude, stoplist[i].latitude],
                    [stoplist[i+1].longitude, stoplist[i+1].latitude]        
                ]
            });
        };
        svg_ls_data.push({
            route_no: item.route,
            route: links,
            length: item.length,
            max_km: item.max_km,
            max_km_ordinal: item.max_km_ordinal,
            ordinal: index + 1
        });  
    });
    let svg_ls_g = svg_ls.append("g")
            .attr("id", "svg_ls_routes");
    
    // Draw the links
    function update_ls(data) {
        data.forEach(function(item) {
            svg_ls_g.selectAll("path")
                .data(item.route)
                .join(
                    function(enter) {
                        return enter
                            .append("path")
                            .attr("class", "svg_ls_ln")
                            .attr("stroke-opacity", "0.01");
                    },
                    function(update) {
                        return update
                            .transition()
                            .duration(750)
                            .attr("stroke-opacity", "0.01");
                    },
                    function(exit) {
                        return exit
                            .transition()
                            .duration(750)
                            .attr("stroke-opacity", "0.01")
                            .on("end", function() {
                                d3.select(this).remove();
                            });
                    }
                )
                .transition()
                .duration(1000)
                .attr("stroke-opacity", "0.30")
                .attr("d",geopath);
        });
    };

    let svg_ls_text = svg_ls.append("g")
        .attr("id", "svg_ls_txt");
    
    function update_ls_text(data) {
        // Add pointer to label
        svg_ls_text.selectAll("path")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("path")
                        .attr("class", "svg_ls_ptr");
                },
                function(update) {
                    return update
                },
                function(exit) {
                    return exit
                        .transition()
                        .duration(750)
                        .attr("stroke-opacity", "0.01")
                        .on("end", function() {
                            d3.select(this).remove();
                        });      
                }
            )
            .attr("stroke-opacity", "0.75")
            .transition()
            .duration(1000)
            .attr("d", d => 
                "M" + projection(d.route[0].coordinates[0])[0] +
                "," + projection(d.route[0].coordinates[0])[1] +
                "L" + "730" +
                "," + "510"
            );
        
        // Hack to 'buffer' the label
        svg_ls_text.selectAll("rect")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("rect")
                        .attr("x", "700")
                        .attr("y", "490")
                        .attr("width", "100px")
                        .attr("height", "100px")
                        .attr("fill", "var(--bg0)")
                        .attr("transform", "translate(-15, -30)");
                }
            );

        // Add label
        let textspace = svg_ls_text.selectAll("text")
            .data(data)
            .join(
                function(enter) {
                    return enter
                        .append("text")
                        .attr("class", data.route_no)
                        .attr("style","font-family:'Inconsolata';")
                        .attr("transform", "translate(700,490)");
                },
                function(exit) {
                    return exit
                        .on("end", function() {
                            d3.select(this).remove();
                        });
                }
            );
        
        textspace.text(d => "Bus " + d.route_no)
            .attr("dy","0")
            .attr("font-size", "1.9em")
            .transition()
            .duration(1000)
            .attr("transform", "translate(700,490)");
        
        textspace.append("tspan")
            .attr("dy", "1.5em")
            .attr("x", 0)
            .attr("font-size", "0.6em")
            .text(d => d.length + " stops (" + ordinal(d.ordinal) + "-longest)");

        textspace.append("tspan")
            .attr("dy", "1.5em")
            .attr("x", "0")
            .attr("font-size", "0.6em")
            .text(d => d.max_km + " km (" + ordinal(d.max_km_ordinal) + "-longest)");

    };

    // Set initial values
    let initialValue = "51";
    let filteredArray = svg_ls_data.filter(item => item.route_no === `${initialValue}`);
    update_ls(filteredArray);
    update_ls_text(filteredArray);

    // Listen to the input box
    d3.select("#ls_input").on("input", function(d) {
        let selectedValue = this.value;
        let filteredArray = svg_ls_data.filter(item => item.route_no === `${selectedValue}`);
        // Hacky update trick: update_ls_text exits nicely on empty array, but update_ls panics if there are no elements in route[].
        // Hence: do update_ls_text, then populate route if filteredArray is empty, then do update_ls.
        update_ls_text(filteredArray);
        if (filteredArray.length == 0) {
            filteredArray.push({
                route_no: null,
                route: [{}],
                length: null,
                max_km: null,
                max_km_ordinal: null,
                ordinal: null
            });
        };
        update_ls(filteredArray);
    });
    
    // The long, straight lines crossing the island are normal. They represent cross-island services with very large distances between stops.

// 3. Drawing svg route_lengths (bar charts of route lengths)

    // Define min/max      
    ranges.svg_rl = {}  
    ranges.svg_rl.length = [1e6, 0]; // min, max
    routes.forEach(function(item) {
        if (item.length < ranges.svg_rl.length[0]) {
            ranges.svg_rl.length[0] = item.length;
        };
        if (item.length > ranges.svg_rl.length[1]) {
            ranges.svg_rl.length[1] = item.length;
        };
    });
    ranges.svg_rl.max_km = [1e6, 0]; // min, max
    routes.forEach(function(item) {
        if (item.max_km < ranges.svg_rl.max_km[0]) {
            ranges.svg_rl.max_km[0] = item.max_km;
        };
        if (item.max_km > ranges.svg_rl.max_km[1]) {
            ranges.svg_rl.max_km[1] = item.max_km;
        };
    });
    
    // Initialise some important cosmetic variables
    let svg_rl_viewlimit = 50; // Limit at which y-axis text stops being visible
    let svg_rl_viewlimit2 = 100; // Limit at which lollipops become bars
    let svg_rl_init = 25; // Initialise zoom level at this value

    // Attach inputs
    d3.select("div.svg_rl_slider")
        .append("input")
        .attr("type", "range")
        .attr("min", "0")
        .attr("max", "100")
        .attr("value", svg_rl_init)
        .attr("name", "rl_slider")
        .attr("id", "rl_slider")
        .attr("class", "slider");
    let svg_rl_dropdown_form = d3.select("div.svg_rl_dropdown")
        .append("form");
    svg_rl_dropdown_form.append("label")
            .attr("for", "rl_dropdown")
            .text("Sort route by: ")
    let svg_rl_dropdown_form_select = svg_rl_dropdown_form.append("select")
        .attr("name", "rl_dropdown")
        .attr("id", "rl_dropdown");
    svg_rl_dropdown_form_select.append("option")
        .attr("value", "max_km")
        .text("length (km)");
    svg_rl_dropdown_form_select.append("option")
        .attr("value", "length")
        .text("number of stops");
    
    // Define selection to render on
    let svg_rl_bc = svg_rl.append("g")
        .attr("id", "svg_rl_chart")
        .attr("transform", "translate(100,40)");
    let svg_rl_bars = svg_rl_bc.append("g")
        .attr("class", "svg_rl_bars");
    let svg_rl_x = svg_rl_bc.append("g")
        .attr("class", "x_axis");
    let svg_rl_x2 = svg_rl_bc.append("g")
        .attr("class", "x_axis2")
    let svg_rl_y = svg_rl_bc.append("g")
        .attr("class", "y_axis");

    function update_rl(data, slice, factor) {
        // Sort and slice
        data.sort((a,b) => {
            return b[factor] - a[factor];
        });
        let working_data = data.slice(0,slice);

        // Define scales and axes
        let x_scale = d3.scaleLinear()
            .domain([0, ranges.svg_rl[factor][1]*1.05])
            .range([0, w * 0.80])
            .nice();
        let y_scale = d3.scaleBand()
            .domain(working_data.map(({route}) => {return route}))
            .range([0, h * 0.85])
            .paddingInner(0.05);
        svg_rl_bars.attr("transform", "translate(0," + y_scale.bandwidth()/2 + ")");
        let x_axis = d3.axisTop(x_scale);
        let x_axis2 = d3.axisBottom(x_scale);
        let y_axis = d3.axisLeft(y_scale)
            .tickSizeInner(0);


        // Setup axes
        svg_rl_x.call(x_axis)
            .attr("class", "svg_rl_x")
            .attr("transform", "translate(0,-20)");
        svg_rl_x2.call(x_axis2)
            .attr("class", "svg_rl_x2")
            .attr("transform", "translate(0," + (h * 0.90).toString() + ")");
        svg_rl_y.call(y_axis)
            .attr("class", "svg_rl_y");
        
        // Remove y-axis labels if too crowded
        // Also hacked together a 'zoom-out' resize rule
        if (slice <= svg_rl_viewlimit) {
            d3.select(".svg_rl_y").attr("style", "font-size:" + ((1-(slice/svg_rl_viewlimit))*2.5).toString() + "em;stroke-width:0px;font:'Inconsolata',sans-serif;");
        } else {
            d3.select(".svg_rl_y").attr("style", "font-size:0.0em;stroke-width:1px;font:'Inconsolata',sans-serif;");
        }

        // represent with rect so can 'morph' into a density chart seamlessly with rect-height
        svg_rl_bars.selectAll("rect")
            .data(working_data)
            .join(
                function(enter) {
                    return enter
                        .append("rect")
                        .attr("x", x_scale(0))
                        .attr("y", d => y_scale(d.route))
                        .attr("width", "0px")
                        .attr("stroke-width", "0px")
                        .attr("fill", "var(--org)");
                },
                function(update) {
                    return update
                        .attr("y", d => y_scale(d.route));
                },
                function(exit) {
                    return exit
                        .remove();
                }
            )
            .transition()
            .duration(1000)
            .attr("width", d => `${x_scale(d[factor])}px`)
            .attr("height", d => {
                if (
                    slice > svg_rl_viewlimit2 &&
                    working_data.includes(d, Math.floor(985/1000*working_data.length))
                    // Shave off last 1.5% of values when zoomed out
                ) {
                    return "0px";   
                } else if (slice <= svg_rl_viewlimit2) {
                    return "1px";
                    // then turn area chart into lollipops when zoomed in
                } else {
                    return "8px";
                // then turn lollipops into area chart when zoomed out and not in last 1.5% 
                }
            });

        svg_rl_bars.selectAll("circle")
            .data(working_data)
            .join(
                function(enter) {
                    return enter
                        .append("circle")
                        .attr("cx", x_scale(0))
                        .attr("cy", d => y_scale(d.route))
                        .attr("r", "0px");
                },
                function(update) {
                    return update
                        .attr("cy", d => y_scale(d.route));
                },
                function(exit) {
                    return exit
                        .remove();
                }
            )
            .transition()
            .duration(1000)
            .attr("r", d => {
                if (slice <= svg_rl_viewlimit2) {
                    return (((1-(slice/svg_rl_viewlimit2))*2.5)+2).toString() + "px";
                } else {
                    return "0px";
                };
            })
            .attr("cx", d => x_scale(d[factor]));
    };


    // Some kind of benchmark to visualise how many bus routes are 'too long' according to maybe some LTA metric...
    // let mean_route_length = mean(routes.map(({length}) => {return length}));
    // svg_rl_bars.append("line")
    //     .attr("id", "svg_rl_mean")
    //     .attr("x1", x_scale(mean_route_length))
    //     .attr("y1", (h * 0.15).toString())
    //     .attr("x2", x_scale(mean_route_length))
    //     .attr("y2", (h * 0.85).toString())
    //     .attr("style", "stroke:black;stroke-width:1px;");
    
    // very magic function (DO NOT TOUCH)
    function svg_rl_smooth(x) {
        // smooths range of [0,100] to exponential domain
        // x0-x3 are the breakpoints in input
        // y0-y3 are the breakpoints in output
        let x0 =  0, y0 =  8;
        let x1 = 66, y1 = svg_rl_viewlimit;
        let x2 = 83, y2 = svg_rl_viewlimit2;
        let x3 = 100, y3 = routes.length;
        if (x <= x1) {
            return (y0 + ((y1-y0)/(x1-x0)*(x-x0)) )
        } else if (x <= x2) {
            return (y1 + ((y2-y1)/(x2-x1)*(x-x1)) )
        } else if (x <= x3) {
            return (y2 + ((y3-y2)/(x3-x2)*(x-x2)) )
        }
    };
    let svg_rl_facet = "max_km"; // length or max_km
    let svg_rl_slice = svg_rl_init;
    update_rl(routes, svg_rl_init, svg_rl_facet); // initialise

    d3.select("#rl_slider").on("input", function(d) {
        let raw_value = this.value;
        svg_rl_slice = svg_rl_smooth(raw_value);
        update_rl(routes, svg_rl_slice, svg_rl_facet); // data, slice, factor
    });

    d3.select("#rl_dropdown").on("input", function(d) {
        svg_rl_facet = this.value;
        update_rl(routes, svg_rl_slice, svg_rl_facet); // data, slice, factor
    });


// 4. Drawing svg route_viewer (live bus locator based on bus stop) (optional)
// ?. Hexbin of bus service density (number of lines * number of stops) (basically a raw count of all lines' stops within a hex) (can divide by number of stops to figure out number of lines passing through a hex)

});

</script>

</body>
</html>

